<!doctype html>
scene.add(root);
current.scene = root;
current.url = meta.url; current.name = meta.name;
const info = countFacesAndMats(root);
specName.textContent = meta.name; specFaces.textContent = info.faces; specMats.textContent = info.mats.join(', ') || '—';
fitToObject(root);
},xhr=>{},err=>{
console.error('Failed to load model',err); specUrl.textContent = 'Failed to load — check URL & CORS';
// fallback
const placeholder = makePlaceholder(); scene.add(placeholder); current.scene = placeholder; specName.textContent = meta.name; specFaces.textContent = '—'; specMats.textContent = '—';
});
} else {
specUrl.textContent = 'No URL (placeholder)';
const placeholder = makePlaceholder(); scene.add(placeholder); current.scene = placeholder; current.url = null; current.name = meta.name;
specName.textContent = meta.name; specFaces.textContent = '—'; specMats.textContent = '—';
fitToObject(placeholder);
}
}


// fit object to camera view
function fitToObject(obj){
const box = new THREE.Box3().setFromObject(obj);
const size = box.getSize(new THREE.Vector3());
const center = box.getCenter(new THREE.Vector3());
const maxDim = Math.max(size.x,size.y,size.z);
const fov = camera.fov * (Math.PI/180);
let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov/2));
cameraZ *= 1.5; // zoom out a bit
camera.position.set(center.x + cameraZ*0.2, center.y + cameraZ*0.2, center.z + cameraZ);
camera.lookAt(center);
controls.target.copy(center);
controls.update();
}


// UI actions
colorPicker.addEventListener('input', (e)=>{applyColor(e.target.value)});
fitBtn.addEventListener('click', ()=>{ if(current.scene) fitToObject(current.scene); });
toggleGridBtn.addEventListener('click', ()=>{ grid.visible = !grid.visible; });
wireBtn.addEventListener('click', ()=>{
if(!current.scene) return; current.scene.traverse(node=>{if(node.isMesh){ if(node.material){ node.material.wireframe = !node.material.wireframe }}});
});


downloadBtn.addEventListener('click', ()=>{
if(current.url){ window.open(current.url, '_blank'); } else alert('No downloadable URL for the current model. Provide a hosted .glb URL in the models array.');
});


screenshotBtn.addEventListener('click', ()=>{
const data = renderer.domElement.toDataURL('image/png');
const a = document.createElement('a'); a.href = data; a.download = `${(current.name||'model')}.png`; a.click();
});


// render loop
function onWindowResize(){
const w = wrap.clientWidth; const h = wrap.clientHeight; camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h);
}
window.addEventListener('resize', onWindowResize);


function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
animate();


// initialize list and select first
buildList();
loadModelIndex(0);


// Small helpful note to user (console)
console.log('3D Car Models Dashboard ready. Replace models[] URLs with your .glb links. When previewing locally, run a local server to avoid CORS issues (e.g. python -m http.server).');
</script>
</body>
</html>
